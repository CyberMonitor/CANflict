/********************************************************************************************************************
 * \file MCMCAN.c
 * \copyright Copyright (C) Infineon Technologies AG 2020
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the
 *company in which ordinary course of business you are acting and (ii) Infineon
 *Technologies AG or its licensees. If and as long as no such terms of use are
 *agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 *obtaining a copy of the software and accompanying documentation covered by
 *this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software,
 *and to permit third-parties to whom the Software is furnished to do so, all
 *subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 *the above license grant, this restriction and the following disclaimer, must
 *be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 *solely in the form of machine-executable object code generated by a source
 *language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 *SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR
 *ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 *ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *DEALINGS IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "MCMCAN.h"
#include "HwMapping.h"
#include "IfxCan_regdef.h"
#include <Bsp.h>
#include <stdint.h>

#define LSB_MASK 0x01U
#define TEST_MODE_BIT 0x02U
#define MSG_BIT_LEN 112

unsigned g_received = 0;

static const uint16 canMsgToSend[7] = {0x8eee, 0x35a0, 0x6a68, 0x6210, 0x5e97, 0x4417, 0xffc2};

#define PRINTOUT(format, ...)

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/

McmcanType g_mcmcan0, g_mcmcan1; /* Global MCMCAN configuration and control structure    */
/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/* Macro to define Interrupt Service Routine.
 * This macro:
 * - defines linker section as .intvec_tc<vector number>_<interrupt priority>.
 * - defines compiler specific attribute for the interrupt functions.
 * - defines the Interrupt service routine as ISR function.
 *
 * IFX_INTERRUPT(isr, vectabNum, priority)
 *  - isr: Name of the ISR function.
 *  - vectabNum: Vector table number.
 *  - priority: Interrupt priority. Refer Usage of Interrupt Macro for more
 * details.
 */
IFX_INTERRUPT(can0IsrTxHandler, 0, ISR_PRIORITY_CAN_TX);
IFX_INTERRUPT(can0IsrRxHandler, 0, ISR_PRIORITY_CAN_RX);
IFX_INTERRUPT(can1IsrTxHandler, 0, ISR_PRIORITY_CAN_TX + 2);
IFX_INTERRUPT(can1IsrRxHandler, 0, ISR_PRIORITY_CAN_RX + 2);
IFX_INTERRUPT(can0RcvErrHandler, 0, 5);
IFX_INTERRUPT(can1RcvErrHandler, 0, 6);

/**************************************************************/
/* ------------------------- Interrupts -------------------   */
/**************************************************************/
/* Interrupt Service Routine (ISR) called once the TX interrupt has been
 * generated. Turns on the LED1 to indicate successful CAN message transmission.
 */
void can0IsrTxHandler(void) {
    /* Clear the "Transmission Completed" interrupt flag */
    IfxCan_Node_clearInterruptFlag(g_mcmcan0.canSrcNode.node, IfxCan_Interrupt_transmissionCompleted);

    /* Just to indicate that the CAN message has been transmitted by turning on
     * LED1 */
    // IfxPort_togglePin(LED5);
}

void can1IsrTxHandler(void) {
    /* Clear the "Transmission Completed" interrupt flag */
    IfxCan_Node_clearInterruptFlag(g_mcmcan1.canSrcNode.node, IfxCan_Interrupt_transmissionCompleted);

    /* Just to indicate that the CAN message has been transmitted by turning on
     * LED1 */
    //  IfxPort_togglePin(LED7);
}

/* Interrupt Service Routine (ISR) called once the RX interrupt has been
 * generated. Compares the content of the received CAN message with the content
 * of the transmitted CAN message and in case of success, turns on the LED2 to
 * indicate successful CAN message reception.
 */
void can0IsrRxHandler(void) {
    /* Clear the "Message stored to Dedicated RX Buffer" interrupt flag */
    IfxCan_Node_clearInterruptFlag(g_mcmcan0.canDstNode.node, IfxCan_Interrupt_messageStoredToDedicatedRxBuffer);

    /* Read the received CAN message */
    IfxCan_Can_readMessage(&g_mcmcan0.canDstNode, &g_mcmcan0.rxMsg, g_mcmcan0.rxData);

    /* Check if the received data matches with the transmitted one */
    //    if( ( g_mcmcan1.rxData[0] == g_mcmcan1.txData[0] ) &&
    //        ( g_mcmcan1.rxData[1] == g_mcmcan1.txData[1] ) &&
    //        ( g_mcmcan1.rxMsg.messageId == g_mcmcan1.txMsg.messageId ) )
    //    {
    /* Turn on the LED2 to indicate correctness of the received message */
    g_mcmcan0.rcv = TRUE;
    g_received++;
    IfxPort_togglePin(LED6);
    //    }
}

void can1IsrRxHandler(void) {
    /* Clear the "Message stored to Dedicated RX Buffer" interrupt flag */
    IfxCan_Node_clearInterruptFlag(g_mcmcan1.canDstNode.node, IfxCan_Interrupt_messageStoredToDedicatedRxBuffer);

    /* Read the received CAN message */
    IfxCan_Can_readMessage(&g_mcmcan1.canDstNode, &g_mcmcan1.rxMsg, g_mcmcan1.rxData);

    /* Check if the received data matches with the transmitted one */
    //    if( ( g_mcmcan1.rxData[0] == g_mcmcan1.txData[0] ) &&
    //        ( g_mcmcan1.rxData[1] == g_mcmcan1.txData[1] ) &&
    //        ( g_mcmcan1.rxMsg.messageId == g_mcmcan1.txMsg.messageId ) )
    //    {
    /* Turn on the LED2 to indicate correctness of the received message */
    g_mcmcan1.rcv = TRUE;
    IfxPort_togglePin(LED8);
    //    }
}

void can0RcvErrHandler(void) {
    IfxCan_Node_clearInterruptFlag(g_mcmcan0.canDstNode.node, IfxCan_Interrupt_protocolErrorData);

    IfxCan_LastErrorCodeType lastErr = IfxCan_Node_getLastErroCodeStatus(g_mcmcan0.canDstNode.node);

    if(lastErr != IfxCan_LastErrorCodeType_noError) {
        g_mcmcan0.rcvError = lastErr;
        IfxPort_togglePin(LED3);
    }
}

void can1RcvErrHandler(void) {
    IfxCan_Node_clearInterruptFlag(g_mcmcan1.canDstNode.node, IfxCan_Interrupt_protocolErrorData);

    IfxCan_LastErrorCodeType lastErr = IfxCan_Node_getLastErroCodeStatus(g_mcmcan1.canDstNode.node);

    if(lastErr != IfxCan_LastErrorCodeType_noError) {
        g_mcmcan1.rcvError = lastErr;
        IfxPort_togglePin(LED3);
    }
}


/**************************************************************/
/* ------------------------ Normal CAN  -------------------   */
/**************************************************************/

/* Function to initialize MCMCAN module and nodes related for this application
 * use case */
void initSingleMcmcan(McmcanType *can, uint8_t canId, boolean loop) {
    /* ==========================================================================================
     * CAN module configuration and initialization:
     * ==========================================================================================
     *  - load default CAN module configuration into configuration structure
     *  - initialize CAN module with the default configuration
     * ==========================================================================================
     */
    IfxCan_Can_initModuleConfig(&(can->canConfig), canId == 0 ? &MODULE_CAN0 : &MODULE_CAN1);
    IfxCan_Can_initModule(&(can->canModule), &(can->canConfig));

    // Pins definition

    /* ==========================================================================================
     * Source CAN node configuration and initialization:
     * ==========================================================================================
     *  - load default CAN node configuration into configuration structure
     *
     *  - set source CAN node in the "Loop-Back" mode (no external pins are
     * used)
     *  - assign source CAN node to CAN node 0
     *
     *  - define the frame to be the transmitting one
     *
     *  - once the transmission is completed, raise the interrupt
     *  - define the transmission complete interrupt priority
     *  - assign the interrupt line 0 to the transmission complete interrupt
     *  - transmission complete interrupt service routine should be serviced by
     * the CPU0
     *
     *  - initialize the source CAN node with the modified configuration
     * ==========================================================================================
     */
    IfxCan_Can_initNodeConfig(&(can->canNodeConfig), &(can->canModule));
    can->canNodeConfig.baudRate.baudrate = CAN_BAUDRATE;
    can->canNodeConfig.busLoopbackEnabled = loop;
    can->canNodeConfig.nodeId = IfxCan_NodeId_0;
    can->canNodeConfig.baudRate.syncJumpWidth = 16;

    can->canNodeConfig.frame.type = IfxCan_FrameType_transmit;

    can->canNodeConfig.interruptConfig.transmissionCompletedEnabled = TRUE;
    can->canNodeConfig.interruptConfig.traco.priority = ISR_PRIORITY_CAN_TX + (canId * 2);
    can->canNodeConfig.interruptConfig.traco.interruptLine =
        (canId == 0) ? IfxCan_InterruptLine_0 : IfxCan_InterruptLine_2;
    can->canNodeConfig.interruptConfig.traco.typeOfService = IfxSrc_Tos_cpu0;

    can->pinConfig.rxPinMode = IfxPort_InputMode_noPullDevice;
    can->pinConfig.txPinMode = IfxPort_OutputMode_pushPull;
    can->pinConfig.padDriver = IfxPort_PadDriver_cmosAutomotiveSpeed2;
    can->pinConfig.rxPin = (canId == 0) ? &IfxCan_RXD00B_P20_7_IN : &IfxCan_RXD10C_P23_0_IN;
    can->pinConfig.txPin = (canId == 0) ? &IfxCan_TXD00_P20_8_OUT : &IfxCan_TXD10_P23_1_OUT;

    can->canNodeConfig.pins = &(can->pinConfig);
    can->canNodeConfig.messageRAM.baseAddress = (canId == 0) ? (uint32)&MODULE_CAN0 : (uint32)&MODULE_CAN1;

    IfxCan_Can_initNode(&(can->canSrcNode), &(can->canNodeConfig));

    /* ==========================================================================================
     * Destination CAN node configuration and initialization:
     * ==========================================================================================
     *  - load default CAN node configuration into configuration structure
     *
     *  - set destination CAN node in the "Loop-Back" mode (no external pins are
     * used)
     *  - assign destination CAN node to CAN node 1
     *
     *  - define the frame to be the receiving one
     *
     *  - once the message is stored in the dedicated RX buffer, raise the
     * interrupt
     *  - define the receive interrupt priority
     *  - assign the interrupt line 1 to the receive interrupt
     *  - receive interrupt service routine should be serviced by the CPU0
     *
     *  - initialize the destination CAN node with the modified configuration
     * ==========================================================================================
     */
    IfxCan_Can_initNodeConfig(&(can->canNodeConfig), &(can->canModule));
    can->canNodeConfig.baudRate.baudrate = CAN_BAUDRATE;
    can->canNodeConfig.busLoopbackEnabled = loop;
    can->canNodeConfig.nodeId = IfxCan_NodeId_0;

    can->canNodeConfig.frame.type = IfxCan_FrameType_receive;

    can->canNodeConfig.interruptConfig.messageStoredToDedicatedRxBufferEnabled = TRUE;
    can->canNodeConfig.interruptConfig.reint.priority = ISR_PRIORITY_CAN_RX + (canId * 2);
    can->canNodeConfig.interruptConfig.reint.interruptLine =
        (canId == 0) ? IfxCan_InterruptLine_1 : IfxCan_InterruptLine_3;
    can->canNodeConfig.interruptConfig.reint.typeOfService = IfxSrc_Tos_cpu0;


    // Error logging irq
    can->canNodeConfig.interruptConfig.protocolErrorDataEnabled = TRUE;
    can->canNodeConfig.interruptConfig.loi.priority = 5 + canId;
    can->canNodeConfig.interruptConfig.loi.interruptLine =
        (canId == 0) ? IfxCan_InterruptLine_4 : IfxCan_InterruptLine_5;
    can->canNodeConfig.interruptConfig.loi.typeOfService = IfxSrc_Tos_cpu0;
    can->rcvError = 0;

    can->pinConfig.rxPinMode = IfxPort_InputMode_noPullDevice;
    can->pinConfig.txPinMode = IfxPort_OutputMode_pushPull;
    can->pinConfig.padDriver = IfxPort_PadDriver_cmosAutomotiveSpeed2;
    can->pinConfig.rxPin = (canId == 0) ? CAN0_RX : CAN1_RX;
    can->pinConfig.txPin = (canId == 0) ? CAN0_TX : CAN1_TX;

    can->canNodeConfig.pins = &(can->pinConfig);
    can->canNodeConfig.messageRAM.baseAddress = (canId == 0) ? (uint32)&MODULE_CAN0 : (uint32)&MODULE_CAN1;

    IfxCan_Can_initNode(&(can->canDstNode), &(can->canNodeConfig));

    /* ==========================================================================================
     * CAN filter configuration and initialization:
     * ==========================================================================================
     *  - filter configuration is stored under the filter element number 0
     *  - store received frame in a dedicated RX Buffer
     *  - define the same message ID as defined for the TX message
     *  - assign the filter to the dedicated RX Buffer (RxBuffer0 in this case)
     *
     *  - initialize the standard filter with the modified configuration
     * ==========================================================================================
     */
    can->canFilter.number = 0;
    can->canFilter.elementConfiguration = IfxCan_FilterElementConfiguration_storeInRxBuffer;
    can->canFilter.type = IfxCan_FilterType_range;
    can->canFilter.id1 = 0; // start of accepted range
    can->canFilter.id2 = 0xFFFF; // end of accepted range
    can->canFilter.rxBufferOffset = IfxCan_RxBufferId_0;

    IfxCan_Can_setStandardFilter(&(can->canDstNode), &(can->canFilter));

    /* Initialization of the RX message with the default configuration */
    IfxCan_Can_initMessage(&(can->rxMsg));
    /* Invalidation of the RX message data content */
    memset((void *)(&(can->rxData[0])), INVALID_RX_DATA_VALUE, MAXIMUM_CAN_DATA_PAYLOAD * sizeof(uint32));

    can->rcv = FALSE;
}

void initMcmcan(void) {
    initSingleMcmcan(&g_mcmcan0, 0, /*loopback=*/FALSE);
    initSingleMcmcan(&g_mcmcan1, 1, /*loopback=*/FALSE);
}

/* Function to initialize both TX and RX messages with the default data values.
 * After initialization of the messages, the TX message is transmitted.
 */
void transmitCanMessage(unsigned canId) {
    g_mcmcan0.rcv = FALSE;
    g_mcmcan1.rcv = FALSE;
    McmcanType *can = (canId == 0) ? &g_mcmcan0 : &g_mcmcan1;

    /* Initialization of the TX message with the default configuration */
    IfxCan_Can_initMessage(&(can->txMsg));

    /* Define the content of the data to be transmitted */
    can->txData[0] = TX_DATA_LOW_WORD;
    can->txData[1] = TX_DATA_HIGH_WORD;

    /* Set the message ID that is used during the receive acceptance phase */
    can->txMsg.messageId = CAN_MESSAGE_ID;// + canId * 10;
    can->txMsg.dataLengthCode = IfxCan_DataLengthCode_8;

    /* Send the CAN message with the previously defined TX message content */
    while (IfxCan_Status_notSentBusy == IfxCan_Can_sendMessage(&(can->canSrcNode), &(can->txMsg), &(can->txData[0]))) {}
    IfxPort_togglePin(LED3);
}

void transmitFullCanMessage(unsigned canId, uint32 msgId, uint8* payload, uint8 size) {
    g_mcmcan0.rcv = FALSE;
    g_mcmcan1.rcv = FALSE;
    McmcanType *can = (canId == 0) ? &g_mcmcan0 : &g_mcmcan1;

    /* Initialization of the TX message with the default configuration */
    IfxCan_Can_initMessage(&(can->txMsg));

    /* Define the content of the data to be transmitted */
    memcpy((uint8*)can->txData, payload, size);

    /* Set the message ID that is used during the receive acceptance phase */
    can->txMsg.messageId = msgId;// + canId * 10;
    can->txMsg.dataLengthCode = size;

    /* Send the CAN message with the previously defined TX message content */
    while (IfxCan_Status_notSentBusy == IfxCan_Can_sendMessage(&(can->canSrcNode), &(can->txMsg), &(can->txData[0]))) {}
    IfxPort_togglePin(LED3);
}

void transmitCanMessageByte(unsigned canId, uint8_t byte) {
    g_mcmcan0.rcv = FALSE;
    g_mcmcan1.rcv = FALSE;
    McmcanType *can = (canId == 0) ? &g_mcmcan0 : &g_mcmcan1;

    /* Initialization of the TX message with the default configuration */
    IfxCan_Can_initMessage(&(can->txMsg));

    /* Define the content of the data to be transmitted */
    can->txData[0] = (TX_DATA_LOW_WORD & 0xFF) + (byte << 8);
    can->txData[1] = TX_DATA_HIGH_WORD;

    /* Set the message ID that is used during the receive acceptance phase */
    can->txMsg.messageId = CAN_MESSAGE_ID; // + (canId == 0 ? 1 : 0);
    can->txMsg.dataLengthCode = IfxCan_DataLengthCode_2;

    /* Send the CAN message with the previously defined TX message content */
    while (IfxCan_Status_notSentBusy == IfxCan_Can_sendMessage(&(can->canSrcNode), &(can->txMsg), &(can->txData[0]))) {}
}

boolean printRcvMsg(unsigned id) {
    McmcanType *can = (id == 0) ? &g_mcmcan0 : &g_mcmcan1;

    if(!can->rcv)
        return FALSE;

    PRINTOUT("\n\rheader: %x  data: %x %x", can->rxMsg.messageId, can->rxData[0], can->rxData[1]);
    can->rcv = FALSE;

    return TRUE;
}

boolean printLastError(unsigned id) {
    McmcanType *can = (id == 0) ? &g_mcmcan0 : &g_mcmcan1;
    IfxCan_LastErrorCodeType lastErr = IfxCan_Node_getLastErroCodeStatus(g_mcmcan1.canDstNode.node);

    if(can->rcvError == lastErr)
        return FALSE;
    can->rcvError = lastErr;

    switch(can->rcvError) {
        case IfxCan_LastErrorCodeType_stuffError:
            PRINTOUT("\n\rBit stuffing error %d", 0);
            break;
        case IfxCan_LastErrorCodeType_formError:
            PRINTOUT("\n\rSome fixed field has a wrong value %d", 0);
            break;
        case IfxCan_LastErrorCodeType_ackError:
            PRINTOUT("\n\rNo ack received %d", 0);
            break;
        case IfxCan_LastErrorCodeType_bit1Error:
            PRINTOUT("\n\rWrote 1 but read 0 %d", 0);
            break;
        case IfxCan_LastErrorCodeType_bit0Error:
            PRINTOUT("\n\rWrote 0 but read 1 %d", 0);
            break;
        case IfxCan_LastErrorCodeType_crcError:
            PRINTOUT("\n\rCRC error %d", 0);
            break;
        default:
            PRINTOUT("\n\rAll good %d", 0);
            break;
    }

    return TRUE;
}

void printNReceived() {
    PRINTOUT("\n\rMessages received by CAN0: %d", g_received);
}
